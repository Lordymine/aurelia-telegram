# Story 1.3: CLI & Interactive Setup Wizard

## Status

**Approved**

## Story

**As a** developer,
**I want** to run `npx aurelia-telegram init` to configure my bot interactively,
**so that** setup is guided and error-free.

## Acceptance Criteria

1. CLI com Commander.js: comandos `init`, `start`, `stop`, `status`, `config`
2. `init` wizard interativo: solicita bot token, telegram_id, project path
3. Validação do bot token (testa conexão com Telegram API via `getMe`)
4. Validação do telegram_id (formato numérico inteiro positivo)
5. Detecção automática de projeto AIOS no path (verifica existência de `.aios-core/`)
6. Salva configuração via config system (Story 1.2 — `saveConfig()`)
7. Mensagem de sucesso com instruções de próximos passos
8. `aurelia-telegram start` inicia o bot, `stop` para, `status` mostra estado

## CodeRabbit Integration

> **CodeRabbit Integration**: Disabled
>
> CodeRabbit CLI is not enabled in `core-config.yaml`.
> Quality validation will use manual review process only.
> To enable, set `coderabbit_integration.enabled: true` in core-config.yaml

## Tasks / Subtasks

- [ ] Task 1: Set up Commander.js program with subcommands (AC: 1)
  - [ ] 1.1 Replace stub in `src/cli/index.ts` with full Commander.js program defining commands: `init`, `start`, `stop`, `status`, `config`
  - [ ] 1.2 Export `createCLI(): Command` function that returns the configured program
  - [ ] 1.3 Create `src/cli/commands/` directory with individual command files
  - [ ] 1.4 Wire `bin/aurelia-telegram.js` to call `createCLI().parse()` (currently stub, missing parse call)
- [ ] Task 2: Implement `init` wizard command (AC: 2, 3, 4, 5, 6, 7)
  - [ ] 2.1 Create `src/cli/commands/init.ts` with init command handler
  - [ ] 2.2 Create `src/cli/wizard.ts` with interactive prompts: bot token, telegram_id(s), project path
  - [ ] 2.3 Implement bot token validation: call Telegram `getMe` API to verify token is valid (use native fetch)
  - [ ] 2.4 Implement telegram_id validation: must be positive integer(s), accept comma-separated for multiple users
  - [ ] 2.5 Implement project path detection: check if `.aios-core/` exists at given path, warn if not found (non-blocking)
  - [ ] 2.6 Auto-detect project path from `process.cwd()` as default
  - [ ] 2.7 Save configuration using `saveConfig()` from config system (Story 1.2)
  - [ ] 2.8 Display success message with clear next steps: "Run `aurelia-telegram start` to begin"
- [ ] Task 3: Implement `start` command (AC: 8)
  - [ ] 3.1 Create `src/cli/commands/start.ts` with start command handler
  - [ ] 3.2 Load config via `loadConfig()`, handle missing config error (suggest `init` first)
  - [ ] 3.3 Create bot via `createBot(config)` from bot layer and call `bot.start()` for long polling
  - [ ] 3.4 Implement graceful shutdown on SIGINT/SIGTERM — call `bot.stop()`, log shutdown
  - [ ] 3.5 Log startup info: bot username (from `getMe`), deploy mode, project path
- [ ] Task 4: Implement `stop` command (AC: 8)
  - [ ] 4.1 Create `src/cli/commands/stop.ts` with stop command handler
  - [ ] 4.2 Implement PID file approach: `start` writes PID to `.aurelia/bot.pid`, `stop` reads and sends SIGTERM
  - [ ] 4.3 Handle case where no bot is running (PID file missing or process dead)
- [ ] Task 5: Implement `status` command (AC: 8)
  - [ ] 5.1 Create `src/cli/commands/status.ts` with status command handler
  - [ ] 5.2 Check if bot is running via PID file
  - [ ] 5.3 If running, show: PID, uptime, deploy mode, project path
  - [ ] 5.4 If not running, show: "Bot is not running. Run `aurelia-telegram start`"
- [ ] Task 6: Implement `config` command (AC: 1)
  - [ ] 6.1 Create `src/cli/commands/config.ts` with config command handler
  - [ ] 6.2 `config get [key]` — show config value (mask sensitive fields like botToken)
  - [ ] 6.3 `config set <key> <value>` — update config field and save
  - [ ] 6.4 `config list` — show all config (with masked sensitive fields)
- [ ] Task 7: Update bot stub for minimal start support (AC: 8)
  - [ ] 7.1 Update `src/bot/index.ts` `createBot(config)` to return a real grammY `Bot` instance using `config.botToken`
  - [ ] 7.2 The bot should be startable/stoppable but handlers/middleware will come in Story 1.4
- [ ] Task 8: Write unit tests (AC: all)
  - [ ] 8.1 Create `tests/unit/cli/commands.test.ts` — test CLI program structure, command registration
  - [ ] 8.2 Create `tests/unit/cli/wizard.test.ts` — test validation functions (bot token format, telegram_id parsing, project path detection)
  - [ ] 8.3 Create `tests/unit/cli/init.test.ts` — test init flow with mocked prompts and API calls
  - [ ] 8.4 Create `tests/unit/bot/index.test.ts` — test createBot returns valid Bot instance
  - [ ] 8.5 Mock native `fetch` for bot token validation tests, mock `fs` for PID file operations
- [ ] Task 9: Validation
  - [ ] 9.1 Verify `npm run typecheck` passes
  - [ ] 9.2 Verify `npm run lint` passes
  - [ ] 9.3 Verify `npm test` passes (all new + existing tests)
  - [ ] 9.4 Verify `npm run build` succeeds
  - [ ] 9.5 Manually verify `node dist/cli/index.js --help` shows all commands

## Dev Notes

### Previous Story Insights
[Source: Story 1.2 Dev Agent Record]

- Zod v4 uses `zod/v4` import path (NOT `zod`)
- `loadConfig()` and `saveConfig()` are the main config API from `src/config/manager.ts`
- `loadConfig()` auto-generates encryption metadata on first run — no need to handle this in init
- TypeScript strict mode is enabled with `noUncheckedIndexedAccess`
- ESM only — use `import`, never `require`
- `getConfigPath(projectPath)` utility available for resolving config file location

### CLI Architecture
[Source: docs/architecture.md#Components — CLI Layer]

- **Technology:** Commander.js 12+, inquirer/prompts (for init wizard)
- **Entry point:** `bin/aurelia-telegram.js` — already exists as stub, needs to call `createCLI().parse()`
- **CLI program:** `src/cli/index.ts` — already exists as stub with `createCLI()` export

**Key interfaces from architecture:**
- `aurelia-telegram init` — Interactive setup wizard
- `aurelia-telegram start` — Start bot (foreground or daemon)
- `aurelia-telegram stop` — Stop running bot
- `aurelia-telegram status` — Show bot and connection status
- `aurelia-telegram config [key] [value]` — Get/set configuration

### Prompt Library Choice
[Source: docs/architecture.md#Components — CLI Layer]

Architecture mentions "inquirer (for init wizard prompts)". Developer may use `@inquirer/prompts` (modern ESM-compatible) or Node.js built-in `node:readline/promises`. Choose what is lightest — prefer `node:readline/promises` to avoid adding a dependency, or `@inquirer/prompts` for better UX. If adding a new dependency, add it to `package.json`.

### Bot Layer Integration
[Source: docs/architecture.md#Components — Bot Layer]

- `createBot(config): Bot` — Factory that assembles bot with middleware
- Currently a stub in `src/bot/index.ts` — needs to return a real grammY `Bot` instance
- grammY is already in dependencies (1.39+)
- For Story 1.3, the bot only needs to be **startable/stoppable** — middleware and handlers come in Story 1.4
- `bot.start()` for long polling, `bot.stop()` for shutdown

### Telegram API — Bot Token Validation
[Source: docs/architecture.md#External APIs — Telegram Bot API]

- **Validation endpoint:** `https://api.telegram.org/bot<token>/getMe`
- Returns `{ ok: true, result: { id, is_bot, first_name, username } }` on success
- Returns `{ ok: false, description: "Unauthorized" }` on invalid token
- Use native `fetch` — no need for grammY for validation only

### Project Structure for New Files
[Source: docs/architecture.md#Project Structure]

```
src/cli/
├── index.ts                 # Commander.js program setup (REPLACE existing stub)
├── commands/
│   ├── init.ts              # Interactive setup wizard
│   ├── start.ts             # Start bot
│   ├── stop.ts              # Stop bot
│   ├── status.ts            # Show status
│   └── config.ts            # Get/set config
└── wizard.ts                # Init wizard prompts
```

### Init Wizard — Config Construction
[Source: PO validation finding]

> **Note:** The wizard collects partial data (botToken, allowedUsers, projectPath) but `saveConfig()` expects a full `AureliaConfig` object. To construct it:
> 1. Spread `DEFAULT_CONFIG` as base (provides `version`, `deployMode: 'local'`, `kimi: {}`, `allowedUsers: []`)
> 2. Override with wizard-collected values (botToken, allowedUsers, projectPath)
> 3. Generate `encryption` metadata: `{ salt: randomBytes(16).toString('base64'), iv: randomBytes(16).toString('base64') }`
> 4. Pass the full object to `saveConfig()`
>
> Alternatively, after saving, a subsequent `loadConfig()` will auto-generate encryption if missing — but it's cleaner to include it on first save.

### Start Command — Foreground Only
[Source: PO validation finding]

> **Note:** The `start` command implements foreground mode only (process stays attached to terminal). Daemon mode (background process) is deferred to Epic 4. The PID file approach for `stop`/`status` is a story-level design decision — handle stale PID files (process died without cleanup) by checking if the PID is actually alive before assuming running.

### Config System API (Story 1.2)
[Source: src/config/manager.ts]

```typescript
// Load config (reads file + env vars + validates)
loadConfig(projectPath?: string): Promise<AureliaConfig>

// Save config (encrypts sensitive fields + writes file)
saveConfig(config: AureliaConfig, projectPath?: string): Promise<void>

// Get config file path
getConfigPath(projectPath?: string): string
```

### AureliaConfig Schema
[Source: src/config/schema.ts]

```typescript
{
  version: string;           // '1.0.0'
  botToken: string;          // Required, min 1 char
  allowedUsers: number[];    // Array of positive integers
  projectPath: string;       // Required, min 1 char
  deployMode: 'local' | 'vps';
  webhook?: { url, port, secretToken };
  kimi: { accessToken?, refreshToken?, expiresAt? };
  encryption: { salt, iv };  // Auto-generated by loadConfig
}
```

### Error Handling Pattern
[Source: docs/architecture.md#Error Handling Strategy]

```typescript
class AureliaError extends Error {
  constructor(
    message: string,
    public code: string,
    public userMessage: string,
    public recoverable: boolean
  ) { super(message); }
}
```

- Separate internal error (logged) from user-facing message (shown in CLI)
- Use pino logger for structured logging

### Security Rules
[Source: docs/architecture.md#Coding Standards]

- NEVER log tokens or API keys — use masked display in `config list` (e.g., `bot***en`)
- Config saved via `saveConfig()` handles encryption automatically
- No sensitive data in error messages

### Coding Standards
[Source: docs/architecture.md#Coding Standards]

- Files: kebab-case (`init.ts`, `wizard.ts`)
- Functions: camelCase (`createCLI`, `validateBotToken`)
- Constants: UPPER_SNAKE (`DEFAULT_PROJECT_PATH`)
- Imports: ESM only (`import`), no CommonJS

### Testing

[Source: docs/architecture.md#Testing Strategy]

- **Framework:** Vitest 2+ (already configured)
- **Test location:** `tests/unit/cli/`, `tests/unit/bot/`
- **What to test:**
  - CLI program structure (commands registered correctly)
  - Wizard validation functions (bot token, telegram_id, project path)
  - Init flow with mocked prompts
  - Bot factory returns valid instance
- **Mocking:** Use Vitest's `vi.mock()` for `fetch`, `fs`, `readline`, process signals
- **Convention:** Test files named `*.test.ts`
- **Commands:** `npm test` (all), `npm run test:coverage` (coverage)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-05 | 0.1 | Initial story draft | River (SM) |
| 2026-02-05 | 0.2 | PO validation: added config construction note, foreground-only note, approved | Pax (PO) |

## Dev Agent Record

### Agent Model Used

_To be filled by dev agent_

### Debug Log References

_To be filled by dev agent_

### Completion Notes List

_To be filled by dev agent_

### File List

_To be filled by dev agent_

## QA Results

_To be filled by QA agent_
