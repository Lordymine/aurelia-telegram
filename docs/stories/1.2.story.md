# Story 1.2: Configuration System

## Status

**Draft**

## Story

**As a** developer,
**I want** a configuration system that stores my bot settings securely,
**so that** I don't need to reconfigure every time I start the bot.

## Acceptance Criteria

1. Módulo `src/config/` que lê/escreve `.aurelia/config.json` no diretório do projeto
2. Schema de configuração: `botToken`, `allowedUsers` (telegram_ids), `kimiAuth`, `projectPath`, `deployMode` (local|vps)
3. Validação de config com Zod schema
4. Valores sensíveis (tokens) encriptados no arquivo de config usando AES-256-GCM
5. Funções `loadConfig()` e `saveConfig()` exportadas
6. Fallback para variáveis de ambiente (AURELIA_BOT_TOKEN, AURELIA_ALLOWED_USERS, etc.)
7. Testes unitários para load, save, validate, encrypt/decrypt

## CodeRabbit Integration

> **CodeRabbit Integration**: Disabled
>
> CodeRabbit CLI is not enabled in `core-config.yaml`.
> Quality validation will use manual review process only.
> To enable, set `coderabbit_integration.enabled: true` in core-config.yaml

## Tasks / Subtasks

- [ ] Task 1: Implement Zod config schema (AC: 2, 3)
  - [ ] 1.1 Replace stub in `src/config/schema.ts` with full AureliaConfig Zod schema matching the data model from architecture
  - [ ] 1.2 Export `aureliaConfigSchema`, `AureliaConfig` type, and all sub-schemas (webhookSchema, kimiSchema, encryptionSchema)
  - [ ] 1.3 Add validation helpers: `validateConfig(data): AureliaConfig` that throws descriptive errors on invalid input
  - [ ] 1.4 Add `DEFAULT_CONFIG` constant with sensible defaults (deployMode: 'local', allowedUsers: [])
- [ ] Task 2: Implement AES-256-GCM encryption helpers (AC: 4)
  - [ ] 2.1 Replace stub in `src/config/encryption.ts` with real implementation
  - [ ] 2.2 Implement `deriveKey(machineFingerprint): Buffer` using PBKDF2 (hostname + username + static salt)
  - [ ] 2.3 Implement `encrypt(plaintext, key): { encrypted: string, iv: string, tag: string }`
  - [ ] 2.4 Implement `decrypt(encrypted, iv, tag, key): string`
  - [ ] 2.5 Implement `getMachineFingerprint(): string` from `os.hostname() + os.userInfo().username`
  - [ ] 2.6 Export `encryptValue(value): string` and `decryptValue(encrypted): string` high-level wrappers
- [ ] Task 3: Implement ConfigManager (AC: 1, 5, 6)
  - [ ] 3.1 Replace stub in `src/config/manager.ts` with full implementation
  - [ ] 3.2 Implement `loadConfig(projectPath?: string): Promise<AureliaConfig>` — reads `.aurelia/config.json`, decrypts sensitive fields, validates with Zod
  - [ ] 3.3 Implement `saveConfig(config: AureliaConfig, projectPath?: string): Promise<void>` — encrypts sensitive fields, writes to `.aurelia/config.json`
  - [ ] 3.4 Implement environment variable fallback: if config file missing or field empty, check `AURELIA_BOT_TOKEN`, `AURELIA_ALLOWED_USERS`, `AURELIA_PROJECT_PATH`, `AURELIA_DEPLOY_MODE`, `AURELIA_LOG_LEVEL`
  - [ ] 3.5 Create `.aurelia/` directory automatically if it doesn't exist
  - [ ] 3.6 Implement `getConfigPath(projectPath?: string): string` utility
  - [ ] 3.7 NEVER log decrypted tokens or sensitive values (use pino logger for config operations)
- [ ] Task 4: Update package exports (AC: 5)
  - [ ] 4.1 Update `src/index.ts` to export `loadConfig`, `saveConfig`, `validateConfig`, `AureliaConfig` type
- [ ] Task 5: Write unit tests (AC: 7)
  - [ ] 5.1 Create `tests/unit/config/schema.test.ts` — test valid config, invalid configs (missing fields, wrong types), default values
  - [ ] 5.2 Create `tests/unit/config/encryption.test.ts` — test encrypt/decrypt roundtrip, different key derivations, tamper detection (GCM auth tag)
  - [ ] 5.3 Create `tests/unit/config/manager.test.ts` — test loadConfig (file exists, file missing, invalid JSON), saveConfig (creates directory, writes encrypted), env var fallback
  - [ ] 5.4 Mock `fs` and `os` modules where needed using Vitest mocks
- [ ] Task 6: Validation
  - [ ] 6.1 Verify `npm run typecheck` passes
  - [ ] 6.2 Verify `npm run lint` passes
  - [ ] 6.3 Verify `npm test` passes (all new + existing tests)
  - [ ] 6.4 Verify `npm run build` succeeds

## Dev Notes

### Previous Story Insights
[Source: Story 1.1 Dev Agent Record]

- Zod v4 uses `zod/v4` import path (NOT `zod`)
- All stub files already exist in `src/config/` — replace them, don't create new files
- Existing stubs: `schema.ts` (has basic schema), `manager.ts` (ConfigManager class), `encryption.ts` (Encryption class)
- TypeScript strict mode is enabled with `noUncheckedIndexedAccess`
- ESM only — use `import`, never `require`

### Data Model — AureliaConfig
[Source: docs/architecture.md#Data Models]

```typescript
interface AureliaConfig {
  version: string;                    // Config schema version
  botToken: string;                   // Telegram bot token (encrypted)
  allowedUsers: number[];             // Telegram user IDs whitelist
  projectPath: string;                // Path to AIOS project
  deployMode: 'local' | 'vps';       // Deployment mode
  webhook?: {
    url: string;                      // Webhook URL for VPS mode
    port: number;                     // Webhook listen port
    secretToken?: string;             // Webhook secret for verification
  };
  kimi: {
    accessToken?: string;             // Kimi access token (encrypted)
    refreshToken?: string;            // Kimi refresh token (encrypted)
    expiresAt?: number;               // Token expiration timestamp
  };
  encryption: {
    salt: string;                     // Derived key salt
    iv: string;                       // Initialization vector
  };
}
```

### Encryption Strategy
[Source: docs/architecture.md#Config Manager + Security Architecture]

- **Algorithm:** AES-256-GCM (authenticated encryption)
- **Key Derivation:** PBKDF2 from machine fingerprint (`os.hostname() + os.userInfo().username + STATIC_SALT`)
- **Encrypted fields:** `botToken`, `kimi.accessToken`, `kimi.refreshToken`
- **Purpose:** Prevent casual exposure. NOT designed to resist attackers with machine access
- **Storage:** Salt and IV stored alongside encrypted values in config file
- **Module:** `node:crypto` (native, no external deps)

### Config File Location
[Source: docs/architecture.md#Components]

- Config stored at `{projectPath}/.aurelia/config.json`
- The `.aurelia/` directory is created by the config manager if it doesn't exist
- `.aurelia/` is already in `.gitignore`

### Environment Variable Fallback
[Source: docs/architecture.md#Environment Variables]

| Env Variable | Config Field | Format |
|-------------|-------------|--------|
| `AURELIA_BOT_TOKEN` | `botToken` | string |
| `AURELIA_ALLOWED_USERS` | `allowedUsers` | comma-separated numbers: `123,456` |
| `AURELIA_PROJECT_PATH` | `projectPath` | absolute path |
| `AURELIA_DEPLOY_MODE` | `deployMode` | `local` or `vps` |
| `AURELIA_LOG_LEVEL` | (logger config) | `debug`, `info`, `warn`, `error` |

### Security Rules
[Source: docs/architecture.md#Coding Standards]

- **Config Access:** Always access config through ConfigManager, never read `.aurelia/config.json` directly
- **Secrets in Logs:** NEVER log tokens, API keys, or encrypted values. Use `logger.info({ userId }, 'message')` pattern
- **Error Messages:** Separate internal error (logged) from user-facing message

### File Locations
[Source: docs/architecture.md#Project Structure]

```
src/config/
├── schema.ts      # Zod config schema (REPLACE existing stub)
├── manager.ts     # Load/save/encrypt config (REPLACE existing stub)
└── encryption.ts  # AES-256-GCM helpers (REPLACE existing stub)
```

### Coding Standards
[Source: docs/architecture.md#Coding Standards]

- Files: kebab-case (`config-manager.ts` — but existing file is `manager.ts`, keep it)
- Classes: PascalCase (`ConfigManager`, `Encryption`)
- Functions: camelCase (`loadConfig`, `saveConfig`, `encryptValue`)
- Constants: UPPER_SNAKE (`STATIC_SALT`, `CONFIG_VERSION`)
- Imports: ESM only (`import`), no CommonJS

### Testing

[Source: docs/architecture.md#Testing Strategy]

- **Framework:** Vitest 2+ (already configured)
- **Test location:** `tests/unit/config/`
- **What to test:**
  - Schema validation (valid, invalid, edge cases)
  - Encrypt/decrypt roundtrip
  - Load/save with file system mocking
  - Environment variable fallback
- **Mocking:** Use Vitest's `vi.mock()` for `fs`, `os`, `process.env`
- **Convention:** Test files named `*.test.ts`
- **Commands:** `npm test` (all), `npm run test:coverage` (coverage)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-05 | 0.1 | Initial story draft | River (SM) |

## Dev Agent Record

### Agent Model Used

_To be filled by dev agent_

### Debug Log References

_To be filled by dev agent_

### Completion Notes List

_To be filled by dev agent_

### File List

_To be filled by dev agent_

## QA Results

_To be filled by QA agent_
