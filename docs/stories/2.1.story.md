# Story 2.1: Kimi Device Code Authentication

## Status

**Ready for Review**

## Story

**As a** developer,
**I want** to authenticate with Kimi using my subscription via device code,
**so that** the bot can use my Kimi for Coding account for translation.

## Acceptance Criteria

1. Módulo `src/kimi/auth.ts` implementando OAuth 2.0 Device Authorization Grant (RFC 8628)
2. Flow: bot gera device code → mostra código + URL no Telegram → usuário autoriza no browser → bot recebe access token
3. Token persistence em `.aurelia/config.json` (encriptado)
4. Refresh token automático antes de expiração
5. Comando `/auth` no Telegram para iniciar o flow de autenticação
6. Comando `/auth-status` para verificar estado da autenticação
7. Mensagens claras no Telegram durante todo o flow (código, URL, status)
8. Tratamento de erros: timeout, denied, expired
9. Testes unitários com mocks do Kimi auth endpoint

## CodeRabbit Integration

> **CodeRabbit Integration**: Disabled

## Tasks / Subtasks

- [x] Task 1: Implement device code auth module (AC: 1, 2, 8)
  - [x] 1.1 Create `src/kimi/auth.ts` exporting `KimiAuth` class with device code flow methods
  - [x] 1.2 Implement `requestDeviceCode()`: POST to Kimi device authorization endpoint, return `{ device_code, user_code, verification_uri, expires_in, interval }`
  - [x] 1.3 Implement `pollForToken(deviceCode, interval)`: Poll token endpoint until success, denied, or expired
  - [x] 1.4 Handle error responses: `authorization_pending` (continue polling), `slow_down` (increase interval), `access_denied` (stop, report), `expired_token` (stop, report)
  - [x] 1.5 Implement `refreshAccessToken(refreshToken)`: Use refresh token to get new access token before expiration

- [x] Task 2: Implement token persistence (AC: 3)
  - [x] 2.1 After successful auth, save `kimi.accessToken`, `kimi.refreshToken`, `kimi.expiresAt` to config via `saveConfig()`
  - [x] 2.2 Tokens are encrypted automatically by `saveConfig()` (AES-256-GCM from Story 1.2)
  - [x] 2.3 On bot startup, check if tokens exist and auto-refresh if expired or near expiration (within 5 minutes)

- [x] Task 3: Implement auto-refresh logic (AC: 4)
  - [x] 3.1 Create `isTokenExpired(expiresAt)` utility — returns true if token expired or within 5-minute buffer
  - [x] 3.2 Create `ensureAuthenticated()` method — checks token, refreshes if needed, throws if no tokens
  - [x] 3.3 Schedule periodic token check (setInterval) that refreshes proactively

- [x] Task 4: Create Telegram command handlers for auth (AC: 5, 6, 7)
  - [x] 4.1 Add `/auth` command handler in `src/bot/handlers/commands.ts` — initiates device code flow, sends user_code + verification_uri to chat
  - [x] 4.2 Add `/auth-status` command handler — shows current Kimi auth state (authenticated, token expiry, or not configured)
  - [x] 4.3 Register `/auth` and `/auth-status` commands in bot factory (`src/bot/index.ts`)
  - [x] 4.4 Send progress messages during polling: "Waiting for authorization...", "Authorized!", or error messages

- [x] Task 5: Write unit tests (AC: 9)
  - [x] 5.1 Create `tests/unit/kimi/auth.test.ts` — test requestDeviceCode, pollForToken, refreshAccessToken with mocked fetch
  - [x] 5.2 Test error scenarios: network error, access_denied, expired_token, slow_down
  - [x] 5.3 Test token expiration check and auto-refresh logic
  - [x] 5.4 Test /auth and /auth-status command handlers with mocked KimiAuth

- [x] Task 6: Validation
  - [x] 6.1 Verify `npm run typecheck` passes
  - [x] 6.2 Verify `npm run lint` passes
  - [x] 6.3 Verify `npm test` passes (all new + existing tests)
  - [x] 6.4 Verify `npm run build` succeeds

## Dev Notes

### Kimi Device Code Flow
[Source: docs/architecture.md#Core Workflows — Kimi Device Code Authentication Flow]

The flow follows RFC 8628 (OAuth 2.0 Device Authorization Grant):
1. Bot sends POST to `/device/code` with `client_id` and `scope`
2. Kimi responds with `device_code`, `user_code`, `verification_uri`, `expires_in`, `interval`
3. Bot shows `user_code` and `verification_uri` to user in Telegram
4. Bot polls POST `/token` with `grant_type=urn:ietf:params:oauth:grant-type:device_code` and `device_code`
5. On success: receives `access_token`, `refresh_token`, `expires_in`

### Kimi API Details
[Source: docs/architecture.md#External APIs — Moonshot / Kimi API]

- **Base URL:** `https://api.moonshot.ai/v1`
- **Authentication:** Bearer token (from device code flow)
- **API is OpenAI-compatible**
- Use native `fetch` for HTTP calls

### Device Code Endpoint (assumed based on RFC 8628)

Since the exact Kimi device code endpoints are not publicly documented, we implement a standard RFC 8628 flow with configurable endpoint URLs:

```typescript
const KIMI_AUTH_BASE = 'https://api.moonshot.ai/v1';
const DEVICE_CODE_ENDPOINT = `${KIMI_AUTH_BASE}/auth/device/code`;
const TOKEN_ENDPOINT = `${KIMI_AUTH_BASE}/auth/token`;
```

These can be overridden via config if the actual endpoints differ.

### Token Storage
[Source: docs/architecture.md#Data Models — AureliaConfig]

Tokens are stored in the existing config schema:
```typescript
kimi: {
  accessToken?: string;   // encrypted by saveConfig
  refreshToken?: string;  // encrypted by saveConfig
  expiresAt?: number;     // timestamp
}
```

### Security Rules
- Never log tokens or API keys
- Tokens encrypted at rest via saveConfig (Story 1.2)
- Clear error messages to user, no internal details exposed

### Previous Story Insights
- `createBot(config)` is the bot factory — register new commands there
- `createCommandHandlers(config)` returns handler functions
- Auth middleware already gates all commands (Story 1.4)
- pino logger for structured logging

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-02-05 | 0.1 | Initial story draft | River (SM) |
| 2026-02-05 | 0.2 | PO validation: all 9 ACs traced, approved | Pax (PO) |
| 2026-02-05 | 0.3 | Implementation complete: all 6 tasks done, 110 tests passing | Dex (Dev) |

## Dev Agent Record

### Agent Model Used

Claude Opus 4.6 (claude-opus-4-6)

### Debug Log References

No issues encountered during implementation.

### Completion Notes List

- All 9 ACs implemented and verified
- 110 unit tests across 12 test files (13 new for Kimi auth)
- RFC 8628 device code flow: requestDeviceCode, pollForToken, refreshAccessToken
- Token expiration check with 5-minute buffer
- /auth command: initiates device code flow, shows user_code + verification_uri, polls until success/failure
- /auth_status command: shows current auth state (not configured, expired, or authenticated with time remaining)
- /status command enhanced with dynamic Kimi auth status
- /help and /start updated with auth commands
- Error handling: timeout, access_denied, expired_token, network errors during polling
- No tokens logged — only userId, command names

### File List

| File | Status | Description |
|------|--------|-------------|
| `src/kimi/auth.ts` | Modified | Full device code auth flow (was stub) |
| `src/bot/handlers/commands.ts` | Modified | Added /auth, /auth_status handlers, updated /help, /start, /status |
| `src/bot/index.ts` | Modified | Registered /auth and /auth_status commands |
| `tests/unit/kimi/auth.test.ts` | Created | 13 tests for device code flow |

## QA Results

### Review Date: 2026-02-05

### Reviewed By: Quinn (Test Architect)

### Gate Status

Gate: **PASS** (93/100) — All 9 ACs verified, comprehensive test coverage for auth flow, proper error handling for all RFC 8628 error states.

### Recommended Status

Ready for Done.
